#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 2000-01-25 08:07 PST by <hal@deer>.
# Source directory was `/tmp_mnt/deer/net/deer/home/hal/programming.dir/plod'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   5162 (null) -rw-r--r--
#    142 (null) -rw-r--r--
#  27744 (null) -rwxr-xr-x
#   3523 (null) -rw-r--r--
#   5558 (null) -rw-------
#  15156 (null) -rw-r--r--
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh02155; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= README ==============
if test -f 'README' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'README' '(file already exists)'
else
  $echo 'x -' extracting 'README' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'README' &&
PLOD is a tool designed to help administrators (and others) keep track
of their daily activities.  Since your management will typically have
no idea what you are doing to justify such an exorbitant salary (any
amount of money they may be paying you being classified as
"exorbitant"), and since most people forget what they do themselves,
it's good to keep a record.  Trot your logs out around performance
review time, and show them to your management (after suitable
sanitization) on a regular basis.
X
The interface is designed to make it quick to dash off a simple note
to yourself.  Since most folks who are going to use PLOD also use
email, I've based the interface on Berkeley mail-- tilde escapes and
all (for a list of escapes, try ~h or ~?).  By default, your logs will
be encrypted using the /bin/crypt command-- not secure in the least,
but marginally safe from casual browsing (I tend to vent into my logs
sometimes rather than at those who might be offended and fire me).
You can turn off the encryption if you find it more a hassle than a
comfort.
X
Which brings us to the subject of customization.  Many escape
sequences and variables have already been defined, but you can make
your own changes using your ~/.plodrc file.  This file is interpreted
using eval(), so any valid Perl syntax is acceptable.  Variables may
be customized by editing this script directly, setting an environment
variable with the same name as the PLOD variable, or by doing an
assignment in your .plodrc (.plodrc value supersedes environment value
which beats default value in script).  New tilde escapes may be
defined by assigning a type glob, say *foo, to the global array
%funcs-- the index of the type glob in the array being the character
(single chars only!) of the escape sequence.  &foo should be a
function which performs the escape (any arguments after the escape are
passed in as a single string in @_), and $foo can be a descriptive
help string (see &helpuser()).  Your functions may reference any of
the PLOD customization variables as well as the list @lines, which
contains all information in the current log entry (including the
date/time stamp PLOD adds to the beginning of each entry).  For
examples, consult the PLOD source code or the manual page.
X
PLOD is a living, growing entity.  If you have suggestions for
improvements or new features, or find any bugs, please send them to me
via email.  The latest version of PLOD is always available at
http://www.deer-run.com/~hal/plod/plod.shar
X
Share and enjoy!
X
Hal Pomeranz, hal@deer-run.com
X
===============================================================================
X
History:
X
v1.0 (Original release to comp.lang.perl)
X
X
v1.1 (Second release to comp.lang.perl)
** &pipetocmd() unlinks all temporary files it creates (Pomeranz)
X
** Variable assignment idiom cleaned up (Rantapaa)
X
** LOGDIR and HOME are only prepended to LOGFILE and DEADLOG after
X   .plodrc has been eval-ed and if LOGFILE and DEADLOG are relative
X   paths.  This means that you can change LOGDIR in your .plodrc and
X   really affect where the log files go. (Rantapaa)
X
** eval of .plodrc is done with "do" rather than "cat" (Rantapaa)
X
** You can now do quick one-liner entries on the command line, e.g.
X   "plod Completed modifications to PLOD" (Rantapaa)
X
** Time/date stamp only printed if user is entering info directly from
X   a tty (Rantapaa)
X
** PLOD attempts to create logging directory if it does not exist (Ellis)
X
X
v1.2 (not publicly released)
** Page/Edit/Visual log files from interactive mode or from the shell
X   (Tizard)
X
X
v1.3 (comp.lang.perl again, and also comp.sources.misc)
** Multi-line Perl input function, ~M (Crabb)
X
** Manual page generated (Pomeranz)
X
X
v1.4 (not publicly released)
** Trap for empty log entries and don't add them to log file (Pomeranz)
X
** -C flag to cat logfile to STDOUT (Prestemon)
X
** /etc/plodrc (Lachowski)
X
** $STAMP customization variable (Lachowski/Pomeranz)
X
X
v1.5 (not publicly released)
** Trap for non-existant/zero size/non-executable CRYPTCMD (Pomeranz)
X
X
v1.6 (comp.sources.misc, comp.lang.perl, LISA VII)
** Minor fix to above trap.  Would have been part of v1.5 but I had already
X   distributed v1.5 to a few people.
X
X
v1.7 (comp.lang.perl)
** Minor code cleanup (finally ran perl -w ;-)) (Pomeranz)
X
** -f flag to change user startup file (Dignard)
X
** Modularized &encrypt and &decrypt to allow customization of encryption
X   strategy (Schneebeli)
X
** Manual page updated (Pomeranz)
X
** Relative directory pattern matches corrected (Pomeranz)
X
X
v1.8
** $PREFIX and $SUFFIX variables added (Billingsley)
X
** Error checking on &encrypt and &decrypt (Ziemba)
X
** "plod -[g|G]" switch (Gibson)
X
** $SEPARATOR variable (Pomeranz)
X
** Changed argument passing to logedit(), and pageit(), and improved
X   argument parsing on some tilde escapes (Pomeranz)
X
** Protect filenames that get passed to the shell (Pomeranz)
X
** -s option and $PROMPT to prompt for keys (Schneebeli/Pomeranz)
X
** Argument processing cleaned up (Pomeranz)
X
** $PLODRC variable added (Pomeranz)
X
** $BACKUP file mechanism (Pomeranz)
X
** post-execution routines (Pomeranz)
X
v1.9
** Y2K fixes (Evans)
X
SHAR_EOF
  $shar_touch -am 01250804100 'README' &&
  chmod 0644 'README' ||
  $echo 'restore of' 'README' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'README:' 'MD5 check failed'
a7fb55b54e72a90c1c8d8135af2fcc6f  README
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'README'`"
    test 5162 -eq "$shar_count" ||
    $echo 'README:' 'original size' '5162,' 'current size' "$shar_count!"
  fi
fi
# ============= TODO ==============
if test -f 'TODO' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'TODO' '(file already exists)'
else
  $echo 'x -' extracting 'TODO' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'TODO' &&
* redo argument processing to handle multiple log files (Bob Gibson
X  <rjg@sco.COM>)
X
* delayed loading (ala plum) of tilde escape functions
X
SHAR_EOF
  $shar_touch -am 1102155194 'TODO' &&
  chmod 0644 'TODO' ||
  $echo 'restore of' 'TODO' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'TODO:' 'MD5 check failed'
92fc6791c3a5bc6f5b690c07cbbf4f3f  TODO
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'TODO'`"
    test 142 -eq "$shar_count" ||
    $echo 'TODO:' 'original size' '142,' 'current size' "$shar_count!"
  fi
fi
# ============= plod ==============
if test -f 'plod' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'plod' '(file already exists)'
else
  $echo 'x -' extracting 'plod' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'plod' &&
#!/usr/local/bin/perl
#
#    PLOD-- Personal LOgging Device, v1.9
#    Copyright (C), 1993-1999, Hal Pomeranz (hal@deer-run.com)
#    All rights reserved.  No warranty expressed or implied.
#    PLOD is freely distributable under the same terms as Perl.
#    Inspired by Bill Mendyka (mendyka@dg-rtp.dg.com)
#    Suggestions/Bugfixes:
#	Bobby Billingsley (bobby@dc.dk)
#	David W Crabb (crabb@phoenix.Princeton.EDU)
#	Michel Dignard (dignard@ERE.UMontreal.CA)
#	John Ellis (ellis@rtsg.mot.com)
#	Tim Evans (Tim.Evans@Citicorp.com)
#	Bob Gibson (rjg@sco.COM)
#	Mike Lachowski (mlachow@erenj.com)
#	Eric Prestemon (ecprest@pocorvares.er.usgs.GOV)
#	Erik E. Rantapaa (rantapaa@math.umn.edu)
#	Scot Schneebeli (sls@tct.com)
#	James Tizard (james@ringo.ssn.flinders.edu.au)
#	G. Paul Ziemba (paul@alantec.com)
#
######################### Begin Variable Declarations #########################
#
# All variables have default values which will be superceded by environment
# variables of the same name.  The user's .plodrc is read after all other
# variable assignments, so any assignments there take precedence.
#
# Note that $LOGFILE and $DEADLOG are used as absolute pathnames.  After
# the .plodrc has been evaluated, $LOGDIR or $HOME will be prepended to
# $LOGFILE and $DEADLOG respectively if either of these variables does not
# begin with a '/'.
#
# Set $CRYPTCMD to null if you don't want encryption to be performed.
#
# KEYVAL	key value used by CRYPTCMD
# PROMPT	true if user wants to be prompted for KEYVAL
# CRYPTCMD	encryption command, set this to null for no encryption
# TMPFILE	file name to use for temporary holding
# EDITOR	editor called by ~e
# VISUAL	editor called by ~v
# PAGER         used by ~p and ~h when output longer than one page (see LINES)
# LINES		number of lines on the screen
# LOGDIR	directory containing log files
# LOGFILE	absolute path of log file
# BACKUP	absolute path for backup of current LOGFILE
# HOME		user's home directory
# PLODRC	default user startup file
# DEADLOG	place to drop dead.log file on abort or ~q, also used by ~d
# STAMP		time/date stamp printed at the top of each entry
# PREFIX	string prepended to each line of log entry
# SUFFIX	string appended to each line of log entry
# SEPARATOR	string which separates log entries (should be static)
X
# Some variable values use date/time information
#
($ss, $mm, $hh, $DD, $MM, $YY) = localtime($^T); $MM++; 
X
$KEYVAL = sprintf("pl%d%dod", $YY, $MM);
$PROMPT = 0;
$CRYPTCMD = "/bin/crypt";
$TMPFILE = "/tmp/plodtmp$$";
$HOME = (getpwuid($<))[7];
$EDITOR = "/usr/local/bin/emacs";
$VISUAL = "/usr/local/bin/emacs";
$PAGER =  "/usr/local/bin/less";
$LINES = 24;
$LOGDIR = "$HOME/.logdir";
$LOGFILE = sprintf("%04d%02d", $YY+1900, $MM);
$BACKUP = ".plod$$.bak";
$PLODRC = "$HOME/.plodrc";
$DEADLOG = "dead.log";
$STAMP = sprintf("%02d/%02d/%04d, %02d:%02d --", $MM, $DD, $YY+1900, $hh, $mm);
$PREFIX = '';
$SUFFIX = '';
$SEPARATOR = '-----';
X
X
########################## End Variable Declarations ##########################
######################### Begin Function Declarations #########################
X
X
# Printvar (~=): Output the value of one or more variables.
#
sub printvar {
X   local($vars) = @_;
X   $, = ','; print eval "($vars)"; $, = '';
X   print "\n";
X   print "(continue composing note)\n";
}
$printvar = "\$var[, ...]\tOutput value of variables";
$funcs{'='} = *printvar;
X
X
# Bang (~!): Execute a command in the shell and then return to plod.
#
sub bang {
X   local($cmdline) = @_;
X   system("$cmdline");
X   print "(continue composing note)\n";
}
$bang = "cmdline\tExecute system command and return";
$funcs{'!'} = *bang;
X
X
# Redirect (~>): Pipe the output of a command into the current buffer.
#
sub redirect {
X   local($cmdline) = @_;
X   if (!open(CMD, "$cmdline |")) {
X      warn "*** Unable to execute: $cmdline\n";
X      return;
X   }
X   &readit(CMD);
}
$redirect = "cmdline\tAdd output of given command to buffer";
$funcs{'>'} = *redirect;
X
X
# Pipetocmd (~|): Pipe the contents of the current buffer through a UNIX
# command line and replace the buffer with the result.
#
sub pipetocmd {
X   local($cmdline) = @_;
X   local($header);
X   if (!open(PIPELN, "| $cmdline >$TMPFILE 2>&1")) {	# output to tmp file
X      warn "*** Unable to execute: $cmdline\n";
X      return;
X   }
X   $header = shift @lines if ($STAMP);			# don't include stamp
X   print PIPELN @lines;
X   close(PIPELN);
X   if (!open(INP, "<$TMPFILE")) {
X      warn "*** Unable to get command output\n";
X      unshift(@lines, $header);
X      unlink $TMPFILE;
X      return;
X   }
X   undef @lines;					# replace buffer with
X   @lines = <INP>;					# contents of tmp file
X   close(INP);
X   unlink $TMPFILE;
X   unshift(@lines, $header) if ($STAMP);
X   print "(continue composing note)\n";   
}
$pipetocmd = "cmdline\tPipe contents of buffer through cmdline";
$funcs{'|'} = *pipetocmd;
X
X
# Perlit (~X): Execute Perl code.
#
sub perlit {
X   local($code) = @_;
X   eval "$code";
X   warn $@ if $@;
X   print "(continue composing note)\n";   
}
$perlit = "code\t\tExecute a line of Perl code";
$funcs{'X'} = *perlit;
X
X
# Longperl (~M): Edit then eval a multi-line Perl fragment
#
sub longperl {
X   local($bogus) = @_;
X   local($safename);
X   return(&mistake) if ($bogus);
X   if (@code) {
X      if (!open(TMP, "> $TMPFILE")) {
X         warn "*** Unable to create temporary file\n";
X         return;
X      }
X      print TMP @code;
X      close(TMP);
X   }
X   ($safename = $TMPFILE) =~ s/(\W)/\\$1/g;
X   system("$EDITOR $safename");
X   if (!open(TMP, "< $TMPFILE")) {
X      warn "*** Unable to read buffer\n";
X      return;
X   }
X   undef @code;
X   @code = <TMP>;
X   close(TMP);
X   system("/bin/rm -f $safename*");
X   eval "@code";
X   warn $@ if $@;
X   print "(continue composing note)\n";   
}
$longperl = "\t\tInvoke \$EDITOR on command buffer, then execute as Perl code";
$funcs{'M'} = *longperl;
X
X
# Appendfl (~a): Append contents of buffer to a file and return to plod.
# To overwrite a file with the contents of the buffer, see &writefl().
#
sub appendfl {
X   local($args) = @_;
X   local(@args, $file);
X   if ($args =~ /\S/) {
X      @args = &shellwords($args);
X      if (@args != 1) {
X         warn "*** Only one argument allowed.\n";
X         return;
X      }
X      $file = $args[0];
X   }
X   else {
X      warn "*** No file name specified.\n";
X      return;
X   }
X   if (!open(OUTP, ">> $file")) {
X      warn "*** Could not append to file $file\n";
X      return;
X   }
X   print OUTP @lines;
X   close(OUTP);
X   print "Wrote ", scalar(@lines), " lines to file $file\n";
X   print "(continue composing note)\n";
}
$appendfl = "file\t\tAppend contents of buffer to file";
$funcs{'a'} = *appendfl;
X
X
# Getdead (~d): Suck contents of DEADLOG file into buffer.
#
sub getdead {
X   local($bogus) = @_;
X   return(&mistake) if ($bogus);
X   if (!open(DEAD, "<$DEADLOG")) {
X      warn "*** Unable to open $DEADLOG.\n";
X      return;
X   }
X   &readit(DEAD, $DEADLOG);
}
$getdead = "\t\tIncorporate contents of \$DEADLOG into buffer";
$funcs{'d'} = *getdead;
X
X
# Editbuf (~e) and Visualbuf (~v): Call appropriate editor on buffer.
#
sub editbuf {
X   local($bogus) = @_;
X   return(&mistake) if ($bogus);
X   &calledit($EDITOR);
}
sub visualbuf {
X   local($bogus) = @_;
X   return(&mistake) if ($bogus);
X   &calledit($VISUAL);
}
$editbuf = "\t\tEdit buffer with \$EDITOR";
$visualbuf = "\t\tEdit buffer with \$VISUAL";
$funcs{'e'} = *editbuf;
$funcs{'v'} = *visualbuf;
X
X
# Editlog (~E) and Visuallog (~V): Call appropriate editor on LOGFILE.
#
sub editlog {
X   local($args) = @_;
X   local($file, $key);
X   if ($args =~ /\S/) {
X      ($file, $key) = &shellwords($args);
X      return unless ($file || $key);
X   }
X   &logedit($EDITOR, $file, $key);
X   print "(continue composing note)\n";
}
sub visuallog {
X   local($args) = @_;
X   local($file, $key);
X   if ($args =~ /\S/) {
X      ($file, $key) = &shellwords($args);
X      return unless ($file || $key);
X   }
X   &logedit($VISUAL, $args);
X   print "(continue composing note)\n";
}
$editlog = "[file [key]]\tEdit LOGFILE [or older log] with \$EDITOR";
$visuallog = "[file [key]]\tEdit LOGFILE [or older log] with \$VISUAL";
$funcs{'E'} = *editlog;
$funcs{'l'} = *editlog;
$funcs{'V'} = *visuallog;
X
X
# Helpuser (~h or ~?): Output a list of tilde escapes with associated
# help messages (found in the scalar values of the type globs in %funcs).
# Use the defined PAGER if the output would be more than LINES long.
#
sub helpuser {
X   local($safename);
X   $long = (scalar(keys %funcs) >= $LINES) && open(TMP, ">$TMPFILE");
X   for (sort keys %funcs) {
X      *info = $funcs{$_};
X      if ($long) {
X         print TMP "~$_ $info\n";
X      }
X      else { print "~$_ $info\n"; }
X   }
X   if ($long) {
X      close(TMP);
X      ($safename = $TMPFILE) =~ s/(\W)/\\$1/g;
X      system("$PAGER $safename");
X      unlink $TMPFILE;
X   }
}
$helpuser = "\t\tPrint this message";
$funcs{'h'} = *helpuser;
$funcs{'?'} = *helpuser;
X
X
# Printout (~p):  cat back the current buffer for review.  Use PAGER if
# the buffer is longer than LINES.
#
sub printout {
X   local($bogus) = @_;
X   local($safename);
X   return(&mistake) if ($bogus);
X   if (@lines < $LINES-1 || !open(TMP, ">$TMPFILE")) {
X      print "$SEPARATOR\n";
X      print @lines;
X   }
X   else {
X      print TMP @lines;
X      close(TMP);
X      ($safename = $TMPFILE) =~ s/(\W)/\\$1/g;
X      system("$PAGER $safename");
X      unlink $TMPFILE;
X   }
X   print "(continue composing note)\n";
}
$printout = "\t\tView contents of buffer, one page at a time";
$funcs{'p'} = *printout;
X
X
# Pagelog (~P): Page contents of LOGFILE.
#
sub pagelog {
X   local($args) = @_;
X   local($file, $key);
X   if ($args =~ /\S/) {
X      ($file, $key) = &shellwords($args);
X      return unless ($file || $key);
X   }
X   &pageit($file, $key);
X   print "(continue composing note)\n";
}
$pagelog = "[file [key]]\tView contents of LOGFILE [or older log] with PAGER";
$funcs{'P'} = *pagelog;
$funcs{'L'} = *pagelog;
X
X
# Quitit (~q): Quit plod and attempt to save buffer in DEADLOG.  Also
# called on SIGINT and SIGQUIT via &trapit().
#
sub quitit {
X   local($bogus) = @_;
X   return(&mistake) if ($bogus);
X   &PLODBadExit();
}
$quitit = "\t\tQuit, attempts to save buffer in \$DEADLOG";
$funcs{'q'} = *quitit;
X
X
# Readfile (~r): Append contents of file into buffer.
#
sub readfile {
X   local($args) = @_;
X   local(@args, $file);
X   if ($args =~ /\S/) {
X      @args = &shellwords($args);
X      if (@args != 1) {
X         warn "*** Only one argument allowed.\n";
X         return;
X      }
X      $file = $args[0];
X   }
X   else {
X      warn "*** No file name specified.\n";
X      return;
X   }
X   if (!open(INPT, "<$file")) {
X      warn "*** Unable to open $file.\n";
X      return;
X   }
X   &readit(INPT, $file);
}
$readfile = "file\t\tRead contents of file into buffer";
$funcs{'r'} = *readfile;
X
X
# Writefl (~w): Overwrite file with contents of buffer.  To append to a
# given file, see &appendfl().
#
sub writefl {
X   local($args) = @_;
X   local(@args, $file);
X   if ($args =~ /\S/) {
X      @args = &shellwords($args);
X      if (@args != 1) {
X         warn "*** Only one argument allowed.\n";
X         return;
X      }
X      $file = $args[0];
X   }
X   else {
X      warn "*** No file name specified.\n";
X      return;
X   }
X   if (!open(OUTP, "> $file")) {
X      warn "*** Could not write to file $file\n";
X      return;
X   }
X   print OUTP @lines;
X   close(OUTP);
X   print "Wrote ", scalar(@lines), " lines to file $file\n";
X   print "(continue composing note)\n";
}
$writefl = "file\t\tOverwrite file with contents of buffer";
$funcs{'w'} = *writefl;
X
X
# Exitnow (~x): Exit plod without writing to DEADLOG or LOGFILE.
#
sub exitnow {
X   local($bogus) = @_;
X   return(&mistake) if ($bogus);
X   &PLODNormExit();
}
$exitnow = "\t\tExit without saving buffer";
$funcs{'x'} = *exitnow;
X
X
########################## End Function Declarations ##########################
############################# Begin Main Program ##############################
X
X
# Check for /etc/plodrc and ~/.plodrc and eval() contents.  Exit with an
# error message if eval() complains for any reason.  Environment supercedes
# /etc/plodrc but is overridden by ~/.plodrc.
#
if (-e "/etc/plodrc") {
X   eval { do "/etc/plodrc"; };
X   die "*** Error in /etc/plodrc:\n$@" if $@;
}
X
$BACKUP = $ENV{'BACKUP'} if (defined($ENV{'BACKUP'}));
$CRYPTCMD = $ENV{'CRYPTCMD'} if (defined($ENV{'CRYPTCMD'}));
$DEADLOG = $ENV{'DEADLOG'} if ($ENV{'DEADLOG'});
$PLODRC = $ENV{'PLODRC'} if ($ENV{'PLODRC'});
$EDITOR = $ENV{'EDITOR'} if ($ENV{'EDITOR'});
$HOME = $ENV{'HOME'} if ($ENV{'HOME'});
$KEYVAL = $ENV{'KEYVAL'} if ($ENV{'KEYVAL'});
$LINES = $ENV{'LINES'} if ($ENV{'LINES'});
$LOGDIR = $ENV{'LOGDIR'} if ($ENV{'LOGDIR'});
$LOGFILE = $ENV{'LOGFILE'} if ($ENV{'LOGFILE'});
$PAGER = $ENV{'PAGER'} if ($ENV{'PAGER'});
$PREFIX = $ENV{'PREFIX'} if (defined($ENV{'PREFIX'}));
$PROMPT = $ENV{'PROMPT'} if (defined($ENV{'PROMPT'}));
$STAMP = $ENV{'STAMP'} if (defined($ENV{'STAMP'}));
$TMPFILE = $ENV{'TMPFILE'}if ($ENV{'TMPFILE'});
$VISUAL = $ENV{'VISUAL'} if ($ENV{'VISUAL'});
$SEPARATOR = $ENV{'SEPARATOR'} if ($ENV{'SEPARATOR'});
$SUFFIX = $ENV{'SUFFIX'} if (defined($ENV{'SUFFIX'}));
X
# Set some defaults
#
$grep = $cat = $edit = $page = '';
$pattern = $file = $key = '';
X
# Now process arguments as long as the first thing in @ARGV looks like
# it might be one.  After that, we assume the user is making a one line
# log entry.
#
while ($ARGV[0] =~ /^-\w$/) {
X   $curr = shift @ARGV;
X   if ($curr eq '-f') {
X      &usage unless (@ARGV);
X      $PLODRC = shift @ARGV;
X   }
X   elsif ($curr eq '-s') {
X      $PROMPT = 1;
X   }
X   elsif ($curr eq '-g' || $curr eq '-G') {
X      &usage() if ($grep || $cat || $edit || $page);
X      &usage unless (@ARGV);
X      $grep = $curr;
X      $pattern = shift @ARGV;
X      $file = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X      $key = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X   }
X   elsif ($curr eq '-E' || $curr eq '-V') {
X      &usage() if ($grep || $cat || $edit || $page);
X      $edit = $curr;
X      $file = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X      $key = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X   }
X   elsif ($curr eq '-P') {
X      &usage() if ($grep || $cat || $edit || $page);
X      $page = $curr;
X      $file = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X      $key = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X   }
X   elsif ($curr eq '-C') {
X      &usage() if ($grep || $cat || $edit || $page);
X      $cat = $curr;
X      $file = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X      $key = shift @ARGV unless ($ARGV[0] =~ /^-\w$/);
X   }
X   else { &usage(); }
}
&usage() if (@ARGV && ($grep || $cat || $edit || $page));
X
X
# Now do the .plodrc.  We have to do this here so the user can
# change the location/name of the file with the -f option.
#
$PLODRC = "$HOME/$PLODRC" unless ($PLODRC =~ /^\.?\.?\//);
if (-e $PLODRC) {
X   die "*** $PLODRC is not a regular file.\n" unless (-f $PLODRC);
X   eval { do "$PLODRC"; };
X   die "*** Error in $PLODRC:\n$@" if $@;
}
X
# Prepend parent directories unless we have explicit pathnames
#
$LOGFILE = "$LOGDIR/$LOGFILE" unless ($LOGFILE =~ /^\.?\.?\//);
$DEADLOG = "$HOME/$DEADLOG" unless ($DEADLOG =~ /^\.?\.?\//);
$BACKUP = "$HOME/$BACKUP" if ($BACKUP && !($BACKUP =~ /^\.?\.?\//));
X
# Do a $BACKUP file if $LOGFILE is non-empty.  Failure to create a
# backup is not a fatal error.
#
if ($BACKUP && -s $LOGFILE) {
X   ($safelog = $LOGFILE) =~ s/(\W)/\\$1/g;
X   ($safeback = $BACKUP) =~ s/(\W)/\\$1/g;
X   if (system("cp $safelog $safeback") >> 8) {
X      warn "*** Couldn't create backup file $BACKUP.\n";
X      $BACKUP = '';
X   }
X   else { chmod(0600, $BACKUP); }
}
X
# You can lose your log file if CRYPTCMD is set, but the executable
# doesn't actually exist.
#
&PLODBadExit("There's something wrong with $CRYPTCMD-- I can't deal!\n")
X  if ($CRYPTCMD && !(-e $CRYPTCMD && -x _ && -f _ && -s _));
X
# Extract dirname from $LOGFILE and make sure it exists
#
($dirname = $LOGFILE) =~ s,/[^/]*$,,;
if (!(-d $dirname)) {
X   warn "Attempting to create logging directory, $dirname\n";
X   &PLODBadExit("Attempt failed!\n") unless (mkdir($dirname, 0700));
}
X
# Jam time/date stamp into buffer...
#
push(@lines, "$STAMP\n") if ($STAMP);
X
# Log entry can appear on the command line, otherwise loop until end of
# STDIN or '.' recognized on a line by itself.
#
if ($page) { 
X   &pageit($file, $key);
X   &PLODNormExit();
}
elsif ($edit) {
X   &logedit(($edit eq '-E') ? $EDITOR : $VISUAL, $file, $key);
X   &PLODNormExit();
}
elsif ($grep) {
X   $insensitive = ($grep eq "-g");
X   &loggrep($insensitive, $pattern, $file, $key);
X   &PLODNormExit();
}
elsif ($cat) {
X   $file = $file || $LOGFILE;
X   $file = "$LOGDIR/$file" unless ($file =~ /^\.?\.?\//);
X   &PLODBadExit("$file does not exist.\n") unless (-f $file);
X
X   $key = $key || $KEYVAL;
X   if ($CRYPTCMD) {
X      unless (&decrypt($key, $file, $TMPFILE)) {
X	 unlink($TMPFILE);
X	 &PLODBadExit("*** Can't decrypt $file.\n");
X      }
X      $file = $TMPFILE;
X   }
X   open(INP, "< $file") || &PLODBadExit("Can't read $file\n");
X   while (<INP>) { print; }
X   close(INP);
X   unlink($TMPFILE) if ($CRYPTCMD);
X
X   &PLODNormExit();
}
elsif (@ARGV) { push(@lines, "@ARGV\n"); }
else {
X   if (-t STDIN) {
X      print "$STAMP\n" if ($STAMP);
X      $SIG{'QUIT'} = 'trapit';
X      $SIG{'INT'} = 'trapit';
X   }
X   while (<STDIN>) {
X      if (/^~/) {					# escape sequence:
X         ($esc, $args) = /^~(\S)\s*(.*)$/;		# 1) parse line
X         *glob = $funcs{$esc};				# 2) unpack type glob
X         if (!defined(&glob)) {				# 3) check defined()
X	    warn "Unrecognized escape sequence: ~$esc\n";
X            next;
X         }
X         &glob($args);					# 4) call func w/ args
X      }
X      elsif (/^\.\s*$/) {				# lone dot means end 
X         print "(eot)\n";				# of log entry
X         last;
X      }
X      else {						# else append line to
X         push(@lines, $_);				# log buffer
X      }
X   }
}
X
# Drop out if buffer is empty.  Append a final newline if one isn't there.
#
if (!@lines || (@lines == 1 && $STAMP)) {
X   warn "*** Empty log entry not added to log file\n";
X   &PLODNormExit();
}
$lines[$#lines] = "$lines[$#lines]\n" unless ($lines[$#lines] =~ /\n$/);
X
# Completed log entry now in @lines.  If using encryption, call encryption
# command to decrypt previous log entries (if present).  If not encrypting,
# simply open log file to append.
#
if ($CRYPTCMD) {					# encrypting
X   if (-e $LOGFILE) {
X      unless (&decrypt($KEYVAL, $LOGFILE, $TMPFILE)) {
X         unlink($TMPFILE);
X         &PLODBadExit("*** Unable to decrypt logfile.\n");
X      }
X   }
X   if (!open(LOGFILE, ">> $TMPFILE")) {
X      unlink $TMPFILE;
X      &PLODBadExit("*** Unable to append new log entry\n");
X   }
}
else { 							# not encyrpting
X   if (!open(LOGFILE, ">> $LOGFILE")) {
X      &PLODBadExit("*** Unable to append new log entry\n");
X   }
}
X
# Dump contents of buffer into plain text file.
#
print LOGFILE "$SEPARATOR\n";
if ($PREFIX || $SUFFIX) {
X   print LOGFILE $lines[0];
X   chop(@trunc = @lines[1 .. $#lines]);
X   for (@trunc) { print LOGFILE $PREFIX, $_, $SUFFIX, "\n"; }
}
else { print LOGFILE @lines; }
close(LOGFILE);
X
# If encrypting, replace old log file with new version.  Unlink plain
# text temporary file when done.
#
if ($CRYPTCMD) {
X   unless (&encrypt($KEYVAL, $TMPFILE, "$LOGFILE.$$")) {
X      unlink("$LOGFILE.$$", $TMPFILE);
X      &PLODBadExit("*** Unable to encrypt log.  Previous version restored.\n");
X   }
X   unless (rename("$LOGFILE.$$", $LOGFILE)) {
X      unlink("$LOGFILE.$$", $TMPFILE);
X      &PLODBadExit("*** rename($LOGFILE.$$, $LOGFILE) failed.\n");
X   }
X   chmod 0600, $LOGFILE;
X   unlink $TMPFILE;
}
X
&PLODNormExit();
X
X
############################## End Main Program ###############################
########################### Miscellaneous Functions ###########################
X
X
# Append contents of file $fname (associated with file handle $fh) to buffer.
# Assume $fh is a pipe if $fname is null.  This function called by many tilde
# escapes.
#
sub readit {
X   local($fh, $fname) = @_;
X   push(@lines, <$fh>);
X   print STDOUT ($fname) ? "$fname: " : "Added ";
X   print STDOUT "$. lines";
X   print STDOUT ($fname) ? "\n" : " to buffer.\n";
X   print STDOUT "(continue composing note)\n";
X   close($fh);
}
X
X
# Call the editor $_[0] on the contents of the buffer.  Used by &editbuf()
# and &visualbuf().
#
sub calledit {
X   local($edit) = @_;
X   local($safename);
X   if (!open(EDIT, ">$TMPFILE")) {
X      warn "*** Unable to create file for editing\n";
X      return;
X   }
X   print EDIT @lines;
X   close(EDIT);
X   chmod 0600, $TMPFILE;
X   ($safename = $TMPFILE) =~ s/(\W)/\\$1/g;
X   system("$edit $safename");
X   if (!open(EDIT, "<$TMPFILE")) {
X      warn "*** Unable to read changes, returning to previous state.\n";
X      system("/bin/rm -f $safename*");
X      return;
X   }
X   undef @lines;
X   @lines = <EDIT>;
X   close(EDIT);
X   system("/bin/rm -f $safename*");
X   print "(continue composing note)\n";
}
X
X
# Call the appropriate editor on a log file.  Used by &editlog and &visuallog.
#
sub logedit {
X   local($edit, $file, $key) = @_;
X   local($safename);
X   $key = $key || $KEYVAL;
X   $file = $file || $LOGFILE;
X   $file = "$LOGDIR/$file" unless ($file =~ /^\.?\.?\//);
X   if ($CRYPTCMD) {
X      if (!(-e $file)) {
X	 warn "*** $file does not exist\n";
X	 return;
X      }
X      unless (&decrypt($key, $file, $TMPFILE)) {
X         unlink($TMPFILE);
X         warn "*** Unable to decrypt $file.\n";
X         return;
X      }
X      chmod 0600, $TMPFILE;
X      ($safename = $TMPFILE) =~ s/(\W)/\\$1/g;
X      system("$edit $safename");
X      if (!(-e $TMPFILE) || -z _) {
X         warn "*** Modified file is empty-- restoring old version\n";
X	 unlink $TMPFILE;
X	 return;
X      }
X      unless (&encrypt($key, $TMPFILE, "$file.$$")) {
X         warn "*** Unable to re-encrypt log file.  Changes lost.\n";
X         unlink("$file.$$", $TMPFILE);
X         return;
X      }
X      unless (rename("$file.$$", $file)) {
X         warn "*** rename($file.$$, $file) failed.  Changes lost.\n";
X         unlink("$file.$$", $TMPFILE);
X         return;
X      }
X      chmod 0600, $file;
X      unlink $TMPFILE;
X   }
X   else {
X      ($safename = $file) =~ s/(\W)/\\$1/g;
X      system("$edit $safename");
X   }
}
X
X
# Print all entries from a log file which contain a line matching a
# given pattern.
#
sub loggrep {
X   local($insensitive, $pattern, $file, $key) = @_;
X   local(@entry, $print);
X   
X   $pattern =~ tr/[A-Z]/[a-z]/ if ($insensitive);
X   $key = $key || $KEYVAL;
X   $file = $file || $LOGFILE;
X   $file = "$LOGDIR/$file" unless ($file =~ /^\.?\.?\//);
X   if ($CRYPTCMD) {
X      unless (&decrypt($key, $file, $TMPFILE)) {
X         unlink($TMPFILE);
X         warn "*** Unable to decrypt $file.\n";
X         return;
X      }
X      $file = $TMPFILE;
X   }
X   unless (open(INP, "< $file")) {
X      warn "*** Can't open $file for reading.\n";
X      return;
X   }
X   $print = 0; undef @entry;
X   while (<INP>) {
X      if (/^$SEPARATOR$/o) {
X         print @entry if ($print);
X         $print = 0; undef @entry;
X      }
X      push(@entry, $_);
X      tr/[A-Z]/[a-z]/ if ($insensitive);
X      $print = ($print || /$pattern/o);
X   }
X   print @entry if ($print);
X   close(INP);
X   unlink($TMPFILE) if ($CRYPTCMD);
}
X
X
# Page a log file.
#
sub pageit {
X   local($file, $key) = @_;
X   local($safename);
X   $key = $key || $KEYVAL;
X   $file = $file || $LOGFILE;
X   $file = "$LOGDIR/$file" unless ($file =~ /^\.?\.?\//);
X   if ($CRYPTCMD) {
X      unless (&decrypt($key, $file, $TMPFILE)) {
X         unlink($TMPFILE);
X         warn "*** Unable to decrypt $file.\n";
X         return;
X      }
X      $file = $TMPFILE;
X   }
X   ($safename = $file) =~ s/(\W)/\\$1/g;
X   system("$PAGER $safename");
X   unlink($TMPFILE) if ($CRYPTCMD);
}
X
X
# Taken directly from shellwords.pl as provided with the Perl4.036
# distribution.  Minor tweaks to exit gracefully.
#
sub shellwords {
X    package shellwords;
X    local($_) = join('', @_) if @_;
X    local(@words,$snippet,$field);
X
X    s/^\s+//;
X    while ($_ ne '') {
X	$field = '';
X	for (;;) {
X	    if (s/^"(([^"\\]|\\[\\"])*)"//) {
X		($snippet = $1) =~ s#\\(.)#$1#g;
X	    }
X	    elsif (/^"/) {
X		warn "*** Unmatched double quote in arguments.\n";
X	        return ();
X	    }
X	    elsif (s/^'(([^'\\]|\\[\\'])*)'//) {
X		($snippet = $1) =~ s#\\(.)#$1#g;
X	    }
X	    elsif (/^'/) {
X		warn "*** Unmatched single quote in arguments.\n";
X                return ();
X	    }
X	    elsif (s/^\\(.)//) {
X		$snippet = $1;
X	    }
X	    elsif (s/^([^\s\\'"]+)//) {
X		$snippet = $1;
X	    }
X	    else {
X		s/^\s+//;
X		last;
X	    }
X	    $field .= $snippet;
X	}
X	push(@words, $field);
X    }
X    @words;
}
X
X
# Generic warning message called by all escapes that do not expect arguments
# when @_ is not empty.
#
sub mistake {
X   warn "*** Arguments are not expected for this escape.\n";
}
X
X
# Wrapper for &PLODBadExit()-- called on SIGINT and SIGQUIT.  Wrapper
# required because signal handlers get the signal as an argument, and
# this does not correspond with arguments to &PLODBadExit().
#
sub trapit {
X   &PLODBadExit();
}
X
X
# A mundane usage message, and a dumb comment.
#
sub usage {
X   local($prog);
X   ($prog = $0) =~ s,.*/,,;
X   warn "Usage: $prog [one line log entry]\tor\n";
X   warn "       $prog -C|-E|-V|-P [file [key]]\tor\n";
X   die  "       $prog -g|-G pattern [file [key]]\n";
}
X
X
# Routine called when PLOD exits abnormally.  Attempts recover log
# from backup if it looks like its been blown away, and attempts to
# dump current log buffer into $DEADLOG.  Will call user-defined error
# routine if present.
#
sub PLODBadExit {
X   local($msg) = @_;
X   local($stat, $safeback, $safelog);
X
X   if ($BACKUP && -s $BACKUP && !(-s $LOGFILE)) {
X      ($safeback = $BACKUP) =~ s/(\W)/\\$1/g;
X      ($safelog = $LOGFILE) =~ s/(\W)/\\$1/g;
X      $stat = (system("mv -f $safeback $safelog")>>8) ? "failed!":"succeeded!";
X      warn "*** $LOGFILE truncated or missing.  Restore $stat\n";
X   }
X   open(DEAD, ">> $DEADLOG") || die "Can't open $DEADLOG\n";
X   print DEAD @lines;
X   close(DEAD);
X   &on_error() if (defined(&on_error));
X   die $msg if ($msg);
X   exit(255);
}
X
X
# Routine called when PLOD exits normally.  Missing logfile triggers
# abnormal exit.  Will call user-defined routine if present.
#
sub PLODNormExit {
X   local($stat);
X
X   &PLODBadExit("*** Normal exit aborted!\n")
X                                 if ($BACKUP && -s $BACKUP && !(-s $LOGFILE));
X   unlink($BACKUP) if ($BACKUP);
X   &on_exit() if (defined(&on_exit));
X   exit(0);
}
X
X
# encrypt() and decrypt() are provided to allow users to customize their
# encryption strategy.  UNIX crypt is bidirectional so the functions are
# identical, but other encryption mechanisms might not have this property.
#
sub encrypt {
X   local($key, $inputfl, $outputfl) = @_;
X   local($safekey, $safeinp, $safeout);
X
X   unlink($outputfl);
X
X   if ($PROMPT) {		# Prompt for $KEYVAL if $PROMPT has been set
X      print "File is $file.\n";
X      print "Please enter encryption key: ";
X      system 'stty', '-echo';
X      chop($key = <STDIN>);
X      system 'stty', 'echo';
X      print "\n";
X   }   
X
X   ($safekey = $key) =~ s/(\W)/\\$1/g;
X   ($safeinp = $inputfl) =~ s/(\W)/\\$1/g;
X   ($safeout = $outputfl) =~ s/(\W)/\\$1/g;
X   !(system("$CRYPTCMD $safekey < $safeinp >$safeout") >> 8);
}
X
sub decrypt {
X   local($key, $inputfl, $outputfl) = @_;
X   local($safekey, $safeinp, $safeout);
X
X   unlink($outputfl);
X
X   if ($PROMPT) {		# Prompt for $KEYVAL if $PROMPT has been set
X      print "File is $file.\n";
X      print "Please enter encryption key: ";
X      system 'stty', '-echo';
X      chop($key = <STDIN>);
X      system 'stty', 'echo';
X      print "\n";
X   }   
X
X   ($safekey = $key) =~ s/(\W)/\\$1/g;
X   ($safeinp = $inputfl) =~ s/(\W)/\\$1/g;
X   ($safeout = $outputfl) =~ s/(\W)/\\$1/g;
X   !(system("$CRYPTCMD $safekey < $safeinp >$safeout") >> 8);
}
SHAR_EOF
  $shar_touch -am 01250802100 'plod' &&
  chmod 0755 'plod' ||
  $echo 'restore of' 'plod' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'plod:' 'MD5 check failed'
e3bbfa4705af4b529bd35c9606a528c5  plod
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'plod'`"
    test 27744 -eq "$shar_count" ||
    $echo 'plod:' 'original size' '27744,' 'current size' "$shar_count!"
  fi
fi
# ============= plod.el.v1 ==============
if test -f 'plod.el.v1' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'plod.el.v1' '(file already exists)'
else
  $echo 'x -' extracting 'plod.el.v1' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'plod.el.v1' &&
Newsgroups: comp.lang.perl
XFrom: paul@ascent.com (Paul Foley)
Subject: Emacs interface to PLOD
Message-ID: <PAUL.93Jan21125701@MountRushmore.ascent.com>
Date: 21 Jan 93 12:57:01
Organization: Ascent Technology, Inc., Cambridge Massachusetts
Lines: 119
X
Here is an emacs-lisp interface to PLOD --- the Personal LOgging
Device posted to comp.lang.perl a few days ago.
X
Simplest way to use is M-x plod.
X
There is also an "alarm" interface that will switch you to a PLOD
buffer every so often, in case you forget to invoke it yourself.
X
Enjoy.
X
------------------------------------------------------------------
X
;;;;
;;;; plod.el
;;;;
;;;; Emacs interface to PLOD --- A (Perl) tool to keep track of the work you do
;;;; PLOD was written by hal@deer-run.com (Hal R. Pomeranz).
;;;;
;;;; This software is FREE to all and may be used for any purpose as long as this 
;;;; notice remains intact.  The author does not assume responsibility for anything.
;;;; 
;;;; Suggested addition to .emacs:
;;;; 	(load-library "plod")
;;;; 	(plod-alarm-on 60) ; once an hour
;;;;
;;;; When you are tired of PLODding use "M-x plod-alarm-off"
;;;; 
;;;; Alternately, use "M-x plod" whenever you want to log something.
;;;; 
;;;; paul@ascent.com (Paul Foley)	Wednesday January 20, 1993
X
(require 'shell)
X
;;;
;;; Variables
;;;
X
;; Name of executable --- should be in your $PATH
(defvar plod-program-name "plod")
(defvar plod-buffer-name "*PLOD*")
X
;;;
;;; Manual Interface
;;;
X
(defvar plod-buffer-process nil)
X
;; Interactive command to invoke PLOD in a shell-mode buffer.
;;
X
(defun plod ()
X  "Invoke PLOD."
X  (interactive)
X  ; restart PLOD if necessary
X  (if (not (get-buffer-process plod-buffer-name))
X      (setq plod-buffer-process (start-process "plod-process" plod-buffer-name plod-program-name)))
X  (switch-to-buffer plod-buffer-name t)
X  (if (not (eq major-mode 'shell-mode)) (shell-mode)))
X
X
;;;
;;; Alarm interface
;;;
X
(defvar plod-alarm-on-p nil)		; t if alarm is on
(defvar plod-alarm-process nil)
X
;; run when plod-alarm-process is killed
(defun plod-alarm-sentinel (proc reason)
X  (or (eq (process-status proc) 'run)
X      (setq plod-alarm-on-p nil)
X      (ding) 
X      (message "PLOD alarm off")))
X
;; run every interval & at initial call to plod-alarm-on
(defun plod-alarm-filter (proc string)
X  (if plod-alarm-on-p
X      (plod)
X    (setq plod-alarm-on-p t)))
X
;; Set alarm to call PLOD every so often
;;
(defun plod-alarm-on (interval)
X  "Turn the Emacs PLOD alarm on.  The alarm goes off every INTERVAL minutes
and you will be switched to the PLOD buffer automatically.  
Use plod-alarm-off to stop this behaviour."
X  (interactive "nEnter PLOD alarm interval (in minutes): ")
X  (let ((live (and plod-alarm-process
X		   (eq (process-status plod-alarm-process) 'run))))
X    (if (not live)
X	(progn
X	  (setq plod-alarm-on-p nil)
X	  (if plod-alarm-process
X	      (delete-process plod-alarm-process))
X	  (let ((process-connection-type nil))
X	    (setq plod-alarm-process
X		  (start-process "plod-alarm" nil 
X				 (concat exec-directory "wakeup")
X				 ; convert minutes -> seconds for wakeup
X				 (int-to-string (* 60 interval)))))
X	  (process-kill-without-query plod-alarm-process)
X	  (set-process-sentinel plod-alarm-process 'plod-alarm-sentinel)
X	  (set-process-filter plod-alarm-process 'plod-alarm-filter)))))
X
;; Turn PLOD alarm off
;;
(defun plod-alarm-off ()
X  "Turn the Emacs PLOD alarm off."
X  (interactive)
X  (if plod-alarm-on-p (kill-process plod-alarm-process)))
X
;;; End
--
paul@ascent.com
X...!uunet!ascent!paul
X
X
X
X
X
X
SHAR_EOF
  $shar_touch -am 01250806100 'plod.el.v1' &&
  chmod 0644 'plod.el.v1' ||
  $echo 'restore of' 'plod.el.v1' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'plod.el.v1:' 'MD5 check failed'
d169ad2f4db13ce76451d8dff5cbc44e  plod.el.v1
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'plod.el.v1'`"
    test 3523 -eq "$shar_count" ||
    $echo 'plod.el.v1:' 'original size' '3523,' 'current size' "$shar_count!"
  fi
fi
# ============= plod.el.v2 ==============
if test -f 'plod.el.v2' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'plod.el.v2' '(file already exists)'
else
  $echo 'x -' extracting 'plod.el.v2' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'plod.el.v2' &&
;; Plod sending commands for Emacs.
X
;; This file is not part of GNU Emacs.
X
;; GNU Emacs is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 1, or (at your option)
;; any later version.
X
;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
X
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
;; Suggested addition to .emacs:
;; 	(load-library "plod-mode")
;; 	(plod-alarm-on 60) ; once an hour
;;
;; When you are tired of PLODding use "M-x plod-alarm-off"
;; 
;; Alternately, use "M-x plod" whenever you want to log something.
;; 
;; paul@ascent.com (Paul Foley)	Wednesday January 20, 1993
;; paulh@harlequin.com (Paul Hudson) Later in 1993 (I forget when :-)
X
X
(provide 'plod)
X
(defvar send-plod-function 'plod-send-it
X  "Function to call to send the current buffer as plod.")
X
(defvar plod-mode-map nil)
X
(defun plod-mode ()
X  "Major mode for editing text to be sent to plod.
Like Text Mode but with these additional commands:
C-c C-s  plod-send (send the message)    C-c C-c  plod-send-and-exit"
X  (interactive)
X  (kill-all-local-variables)
X  (make-local-variable 'plod-reply-buffer)
X  (setq plod-reply-buffer nil)
X  (set-syntax-table text-mode-syntax-table)
X  (use-local-map plod-mode-map)
X  (setq local-abbrev-table text-mode-abbrev-table)
X  (setq major-mode 'plod-mode)
X  (setq mode-name "Plod")
X  (setq buffer-offer-save t)
X  (run-hooks 'text-mode-hook 'plod-mode-hook))
X
(if plod-mode-map
X    nil
X  (setq plod-mode-map (make-sparse-keymap))
X  (define-key plod-mode-map "\C-c?" 'describe-mode)
X  (define-key plod-mode-map "\C-c\C-c" 'plod-send-and-exit)
X  (define-key plod-mode-map "\C-c\C-s" 'plod-send))
X
(defun plod-send-and-exit (arg)
X  "Send message like plod-send, then, if no errors, exit from plod buffer.
Prefix arg means don't delete this window."
X  (interactive "P")
X  (plod-send)
X  (bury-buffer (current-buffer))
X  (if (and (not arg)
X	   (not (one-window-p)))
X      (delete-window)
X    (switch-to-buffer (other-buffer (current-buffer)))))
X
(defun plod-send ()
X  "Send the message in the current buffer to plod."
X  (interactive)
X  (message "Sending...")
X  (funcall send-plod-function)
X  (set-buffer-modified-p nil)
X  (delete-auto-save-file-if-necessary)
X  (message "Sending...done"))
X
(defun plod-send-it ()
X  (let ((tembuf (generate-new-buffer " plod temp"))
X	(plodbuf (current-buffer)))
X    (unwind-protect
X	  (call-process-region (point-min) (point-max)
X			       (if (boundp 'plod-program)
X				   plod-program
X				 "/usr/local/bin/plod")
X			       nil tembuf nil)
X      (kill-buffer tembuf))))
X
X
(defun plod (&optional noerase)
X  "Edit a message to be sent.  Argument means resume editing (don't erase).
Returns with message buffer selected; value t if message freshly initialized.
While editing message, type C-c C-c to send the message and exit.
X
\\{plod-mode-map}
X
If plod-setup-hook is bound, its value is called with no arguments
after the message is initialized. "
X  (interactive "P")
X  (switch-to-buffer "*plod*")
X  (setq default-directory (expand-file-name "~/"))
X  (auto-save-mode auto-save-default)
X  (plod-mode)
X  (and (not noerase)
X       (or (not (buffer-modified-p))
X	   (y-or-n-p "Unsent message being composed; erase it? "))
X       (progn (erase-buffer)
X	      (set-buffer-modified-p nil)
X	      (run-hooks 'plod-setup-hook)
X	      t)))
X
(defun plod-other-window (&optional noerase)
X  "Like `plod' command, but display plod buffer in another window."
X  (interactive "P")
X  (let ((pop-up-windows t))
X    (pop-to-buffer "*plod*"))
X  (plod noerase))
X
X
;;;
;;; Alarm interface
;;;
X
(defvar plod-alarm-on-p nil)		; t if alarm is on
(defvar plod-alarm-process nil)
X
;; run when plod-alarm-process is killed
(defun plod-alarm-sentinel (proc reason)
X  (or (eq (process-status proc) 'run)
X      (setq plod-alarm-on-p nil)
X      (ding) 
X      (message "PLOD alarm off")))
X
;; run every interval & at initial call to plod-alarm-on
(defun plod-alarm-filter (proc string)
X  (if plod-alarm-on-p
X      (plod)
X    (setq plod-alarm-on-p t)))
X
;; Set alarm to call PLOD every so often
;;
(defun plod-alarm-on (interval)
X  "Turn the Emacs PLOD alarm on.  The alarm goes off every INTERVAL minutes
and you will be switched to the PLOD buffer automatically.  
Use plod-alarm-off to stop this behaviour."
X  (interactive "nEnter PLOD alarm interval (in minutes): ")
X  (let ((live (and plod-alarm-process
X		   (eq (process-status plod-alarm-process) 'run))))
X    (if (not live)
X	(progn
X	  (setq plod-alarm-on-p nil)
X	  (if plod-alarm-process
X	      (delete-process plod-alarm-process))
X	  (let ((process-connection-type nil))
X	    (setq plod-alarm-process
X		  (start-process "plod-alarm" nil 
X				 (concat exec-directory "wakeup")
X				 ; convert minutes -> seconds for wakeup
X				 (int-to-string (* 60 interval)))))
X	  (process-kill-without-query plod-alarm-process)
X	  (set-process-sentinel plod-alarm-process 'plod-alarm-sentinel)
X	  (set-process-filter plod-alarm-process 'plod-alarm-filter)))))
X
;; Turn PLOD alarm off
;;
(defun plod-alarm-off ()
X  "Turn the Emacs PLOD alarm off."
X  (interactive)
X  (if plod-alarm-on-p (kill-process plod-alarm-process)))
X
;;; End
X
X
SHAR_EOF
  $shar_touch -am 0924084793 'plod.el.v2' &&
  chmod 0600 'plod.el.v2' ||
  $echo 'restore of' 'plod.el.v2' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'plod.el.v2:' 'MD5 check failed'
db7ba88fe8de9bf615a721ec5c9a4b2b  plod.el.v2
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'plod.el.v2'`"
    test 5558 -eq "$shar_count" ||
    $echo 'plod.el.v2:' 'original size' '5558,' 'current size' "$shar_count!"
  fi
fi
# ============= plod.man ==============
if test -f 'plod.man' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'plod.man' '(file already exists)'
else
  $echo 'x -' extracting 'plod.man' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'plod.man' &&
X.nh
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X.de Ip
X.br
X.ie \\n.$>=3 .ne \\$3
X.el .ne 3
X.IP "\\$1" \\$2
X..
X.TH PLOD 1 "2 November 1994" "PLOD"
X.SH NAME
plod \- keep a log of your work
X.SH SYNOPSIS
X.B plod
\ [\ -s\ ]\ [\ -f \fIfile\fR\ ]\ [\ \fIone line message\fR\ ]
X.br
X.B plod
\ [\ -s\ ]\ [\ -f \fIfile\fR\ ]
\fB-C\fR|\fB-E\fR|\fB-P\fR|\fB-V\fR\ [\ \fIlogfile\fR\ [\ \fIkey\fR\ ]]
X.br
X.B plod
\ [\ -s\ ]\ [\ -f \fIfile\fR\ ]
\fB-g\fR|\fB-G\fR\ \fIpattern\fR\ [\ \fIlogfile\fR\ [\ \fIkey\fR\ ]]
X.SH DESCRIPTION
\fBPLOD\fR
is a tool developed to help System/Network Administrators (and others)
keep track of the work that they do.  Good logs are useful both as a
personal reference and to show to your management on a regular basis
or around performance review time. By default, logs will be stored in
an encrypted format in the directory \fI$HOME/.logdir\fR, but this
behavior is completely customizable (see \fBENVIRONMENT\fR and 
\fBCUSTOMIZATION\fR below).
X
The first form of the command will enter a short message on the command
line into your log file.  If no message is present on the command line,
a date/time stamp will be printed and \fBPLOD\fR
will go into an interactive mode reminiscent of BSD mail.  Many tilde
escape sequences are supported (see \fBCOMMANDS\fR below or type 
\fI~h\fR or \fI~?\fR within interactive mode).  Enter a period on a
line by itself to end your log entry.
X
The second mode allows you to review or edit your old log files.  The
\fB-P\fR option invokes the default \fBPAGER\fR defined in the \fBPLOD\fR
source, or as defined in your environment, on the current log file.  The
\fB-E\fR and \fB-V\fR flags invoke \fBEDITOR\fR and \fBVISUAL\fR respectively.
The \fB-C\fR option will simply dump the current log file to the
standard output.  This is useful for piping your log file to other
commands, such as \fBlpr\fR.
Older log files may be accessed by specifying a file name and optional
encryption key on the command line.
X
The third mode allows you to search your logs for a particular pattern
but, unlike \fBgrep\fR(1), \fBPLOD\fR displays the entire log entry 
rather than just the line which matches the pattern.
The \fB-g\fR flag specifies a case-insensitive match, while \fB-G\fR
does a case sensitive search.  The \fIpattern\fR may be any valid Perl
regular expression.  Don't forget to quote the pattern to protect
any special characters from the shell.
X
In any mode, the \fB-f\fR flag allows the user to specify a different
startup file than the default (\fI$HOME/.plodrc\fR).  The \fB-s\fR
flag tells \fBPLOD\fR to prompt the user for their encryption key.
When making a one-line log entry, the \fB-f\fR and \fB-s\fR options must
appear first on the command line.
X
X.SH ENVIRONMENT
\fBPLOD\fR supports a number of variables which can be modified to customize
its behavior.  The values of these variables may be changed by editing
\fBPLOD\fR directly, by assignment in a system-wide startup file, 
by creating an environment variable, or by assignment
in the user's startup file (see \fBCUSTOMIZATION\fR below).  \fBPLOD\fR
recognizes the following environment variables:
X.Ip "\fBSEPARATOR\fR" 4
A string used to separate one entry from another in the log file.  This
string must be constant throughout the entire file or the \fB-g\fR and
\fB-G\fR command line options will not work correctly.  Default is
\fI-----\fR (five dashes).
X.Ip "\fBSTAMP\fR" 4
The time/date stamp entered into every log entry.  Set this to null if you
do not wish to datestamp your logs.  Default is \fIMM/DD/YY, HH:MM --\fR.
X.Sp
X.Ip "\fBPREFIX\fR" 4
String to be prepended to each line of log entry as it goes into your log
file.  Default is the empty string.
X.Sp
X.Ip "\fBSUFFIX\fR" 4
String to be appended to each line of log entry as it goes into your log
file.  Default is the empty string.
X.Sp
X.Ip "\fBEDITOR\fR" 4
The user's preferred editor (used by the \fB-E\fR command line flag and the
\fB~e\fR, \fB~E\fR, and \fB~M\fR escape sequences).  Default is 
\fI/usr/local/bin/emacs\fR.
X.Sp
X.Ip "\fBVISUAL\fR" 4
The user's preferred visual editor (used by \fB-V\fR, \fB~v\fR, and \fB~V\fR).
Default is \fI/usr/local/bin/emacs\fR.
X.Sp
X.Ip "\fBPAGER\fR" 4
The user's preferred pager (used by \fB-P\fR, \fB~p\fR, and \fB~P\fR).
Default is \fI/usr/local/bin/less\fR.
X.Sp
X.Ip "\fBLINES\fR" 4
The number of lines on the current display.  Used to determine when the
\fBPAGER\fR needs to be invoked. Default is \fI24\fR.
X.Sp
X.Ip "\fBCRYPTCMD\fR" 4
The encryption command to be used.  If you do not wish to encrypt your
log files, set this to null.
Default is \fI/bin/crypt\fR (the standard UNIX \fBcrypt\fR command is
not in the least secure, but does provide protection from casual browsing).
X.Sp
X.Ip "\fBKEYVAL\fR" 4
The key to be used with \fBCRYPTCMD\fR.  Default is \fIpl<yr><mn>od\fR.
X.Sp
X.Ip "\fBPROMPT\fR" 4
Setting this variable to true (non-zero) causes \fBPLOD\fR to prompt
the user for their encryption key rather than using \fBKEYVAL\fR.
This is equivalent to using the \fB-s\fR flag
on the command line.  Default is \fIfalse\fR (zero).
X.Sp
X.Ip "\fBLOGDIR\fR" 4
Where log files are placed.  Default is \fI$HOME/.logdir\fR.
X.Sp
X.Ip "\fBLOGFILE\fR" 4
The name of the current log file.  \fBLOGDIR\fR will be prepended to this
value if \fBLOGFILE\fR is not an absolute path.  Default is
\fI<yr><mn>\fR.
X.Sp
X.Ip "\fBHOME\fR" 4
The user's home directory.  Default taken from user's password entry.
X.Sp
X.Ip "\fBPLODRC\fR" 4
The name of the user's startup file.  Can also be set with
the \fB-f\fR command line switch.  Obviously, there isn't a lot of
point in trying to set this in your \fI.plodrc\fR file.  \fBHOME\fR
will be prepended
to this value of \fBPLODRC\fR is not an absolute path.  Default
is \fI.plodrc\fR.
X.Sp
X.Ip "\fBBACKUP\fR" 4
The current \fBLOGFILE\fR is copied to \fBBACKUP\fR as the program begins
execution.  If, when the program terminates, the \fBLOGFILE\fR is gone or
zero-length, then it is replaced the the \fBBACKUP\fR copy and the current
log entry is dumped to \fBDEADLOG\fR.  Setting \fBBACKUP\fR to null disables
this feature.  The value of \fBHOME\fR is prepended if \fBBACKUP\fR is
not an absolute path.  Default is \fI.plod<pid>.bak\fR.
X.Sp
X.Ip "\fBDEADLOG\fR" 4
Where interrupted log entries are placed.  \fBHOME\fR will be prepended
to this value if \fBDEADLOG\fR is not an absolute path.  Default
is \fIdead.log\fR.
X.Sp
X.Ip "\fBTMPFILE\fR" 4
Scratch file used throughout execution of program.  Default is 
\fI/tmp/plodtmp<pid>\fR.
X.Sp
X
X.SH COMMANDS
Many tilde escape sequences are supported under \fBPLOD\fR's interactive
mode.  Users may also define their own escape sequences in \fBPLOD\fR's
initialization file (see \fBCUSTOMIZATION\fR below).  Currently defined
sequences are:
X.Ip "~h, ~?" 8
Show a list of all escape sequences with a short usage message.
X.Sp
X.Ip "~= var[, ...]" 8
Display the current value of one or more variables.
X.Ip ~e 8
Edit the current buffer with \fB$EDITOR\fR.
X.Sp
X.Ip ~v 8
Edit the current buffer with \fB$VISUAL\fR.
X.Sp
X.Ip ~p 8
Display the contents of the current buffer (using \fB$PAGER\fR if necessary).
X.Sp
X.Ip "~V [\ logfile\ [\ key\ ]]" 8
Call \fB$VISUAL\fR on the current log file, or on some other log file as
specified.  An additional encryption key may also be supplied.
X.Sp
X.Ip "~E, ~l [\ logfile\ [\ key\ ]]" 8
Similar to ~E except that \fB$EDITOR\fR is used.
X.Sp
X.Ip "~P, ~L [\ logfile\ [\ key\ ]]" 8
Same as ~E and ~V except that \fB$PAGER\fR is invoked.
X.Sp
X.Ip ~q 8
Quit \fBPLOD\fR, saving contents of buffer into \fB$DEADLOG\fR.
X.Sp
X.Ip ~x 8
Quit without attempting to save buffer.
X.Sp
X.Ip ~d 8
Append contents of \fB$DEADLOG\fR to current buffer.
X.Sp
X.Ip "~r somefile" 8
Append contents of file to current buffer.
X.Sp
X.Ip "~a somefile" 8
Append contents of current buffer to file.
X.Sp
X.Ip "~w somefile" 8
Overwrite file with contents of current buffer.
X.Sp
X.Ip "~X Perl-code" 8
Execute a line of Perl code.
X.Sp
X.Ip ~M 8
Invoke \fB$EDITOR\fR and execute resulting file as Perl code.  Each successive
invocation of this escape will edit the previously executed Perl code so as
to make it easier to go back and correct small errors.
X.Sp
X.Ip "~! command" 8
Execute a command in the shell and return.
X.Sp
X.Ip "~> command" 8
Append the output of a command to the current buffer.
X.Sp
X.Ip "~| command" 8
Pipe the current buffer through a command and replace the buffer with the
resulting output.
X.Sp
X
X.SH CUSTOMIZATION
Like most UNIX utilities, \fBPLOD\fR has an initialization file,
the \fI\.plodrc\fR,
which is read at startup.  Unlike most UNIX utilities,
this file is interpreted as Perl code.  Thus, if you wished to assign
a new value to a customization variable you would use the syntax
X.RS
X.PP
$LOGDIR = "$HOME/mylogs";
X.RE
X.PP
The location of the user startup file may changed with the \fB-f\fR
command line switch or by setting the \fBPLODRC\fR environment variable.
X
\fBPLOD\fR also looks for a system-wide customization file, \fI/etc/plodrc\fR.
The order of evaluation is: hard coded defaults in \fBPLOD\fR, then
the \fI/etc/plodrc\fR file, then the user's environment, and finally the
user's \fBPLODRC\fR file.
X
Beyond simple variable customization, the \fBPLODRC\fR file can be
used as an automatic pre-execution block and to define subroutines
that will be used during the execution of the program.  For
example, \fBPLOD\fR will attempt to execute
user-defined \fI&on_exit()\fR or \fI&on_error()\fR routines (if they
are defined) when the program terminates, depending upon whether the
program exits normally or abnormally.
X
Another application of this feature is to change the encryption
scheme used by \fBPLOD\fR to use some alternate (more secure) encryption
mechanism.  Encryption and decryption in \fBPLOD\fR are done
via \fI&encrypt()\fR and \fI&decrypt()\fR routines.  Both routines accept
the same three arguments:  a key value, an input file (either encrypted
or decrypted depending upon which routine is being called), and an output
file to place the result into.  The routines must return non-zero upon
success and zero on failure, and should prompt the user for an
encryption key if \fBPROMPT\fR is set.  As an example, here are the default
\fI&encrypt()\fR and \fI&decrypt()\fR routines from the \fBPLOD\fR source:
X.RS
X.PP
X.nf
sub encrypt {
X   local($key, $inputfl, $outputfl) = @_;
X   local($safekey, $safeinp, $safeout);
X
X   unlink($outputfl);
X
X   if ($PROMPT) {	# Prompt for $KEYVAL if $PROMPT has been set
X      print "File is $file.\n";
X      print "Please enter encryption key: ";
X      system 'stty', '-echo';
X      chop($key = <STDIN>);
X      system 'stty', 'echo';
X      print "\n";
X   }   
X
X   ($safekey = $key) =~ s/(\W)/\\$1/g;
X   ($safeinp = $inputfl) =~ s/(\W)/\\$1/g;
X   ($safeout = $outputfl) =~ s/(\W)/\\$1/g;
X   !(system("$CRYPTCMD $safekey < $safeinp >$safeout") >> 8);
}
X
sub decrypt {
X   local($key, $inputfl, $outputfl) = @_;
X   local($safekey, $safeinp, $safeout);
X
X   unlink($outputfl);
X
X   if ($PROMPT) {	# Prompt for $KEYVAL if $PROMPT has been set
X      print "File is $file.\n";
X      print "Please enter encryption key: ";
X      system 'stty', '-echo';
X      chop($key = <STDIN>);
X      system 'stty', 'echo';
X      print "\n";
X   }   
X
X   ($safekey = $key) =~ s/(\W)/\\$1/g;
X   ($safeinp = $inputfl) =~ s/(\W)/\\$1/g;
X   ($safeout = $outputfl) =~ s/(\W)/\\$1/g;
X   !(system("$CRYPTCMD $safekey < $safeinp >$safeout") >> 8);
}
X.fi
X.RE
X.PP
Note that any possible meta characters in the key or in filenames 
are protected from the shell with
backslashes before they are passed to \fIsystem()\fR.  An \fI&encrypt()\fR
or \fI&decrypt()\fR routine defined in the \fBPLODRC\fR will supercede the
default definitions in the \fBPLOD\fR source.
X
It is also possible for the user to create their own tilde escapes.  First,
create a subroutine which performs the desired function.  Then assign the
type glob which references that function to global array \fI%funcs\fR indexed
by the character of the escape sequence.  Any arguments that the user enters
after the tilde escape will be passed into the function as a single string
in \fI@_\fR.  The list \fI@lines\fR contains the current buffer.
X
As an example, here is the append to file function (~a) from the \fBPLOD\fR
source:
X.RS
X.PP
X.nf
sub appendfl {
X   local($file) = @_;
X   if (!open(OUTP, ">> $file")) {
X      warn "*** Could not append to file $file\\n";
X      return;
X   }
X   print OUTP @lines;
X   close(OUTP);
X   print "Wrote ", scalar(@lines), " lines to file $file\\n";
X   print "(continue composing note)\\n";
}
$appendfl = "file\\t\\tAppend contents of buffer to file";
$funcs{'a'} = *appendfl;
X.fi
X.RE
X.PP
The scalar variable \fI$appendfl\fR is used by \fBPLOD\fR's help function
(~h or ~?) to provide a descriptive message about the escape sequence.
As a further example, here is \fBPLOD\fR's help function
X.RS
X.PP
X.nf
sub helpuser {
X   local($safename);
X   $long = (scalar(keys %funcs) >= $LINES) && open(TMP, ">$TMPFILE");
X   for (sort keys %funcs) {
X      *info = $funcs{$_};
X      if ($long) {
X         print TMP "~$_ $info\n";
X      }
X      else { print "~$_ $info\n"; }
X   }
X   if ($long) {
X      close(TMP);
X      ($safename = $TMPFILE) =~ s/(\W)/\\$1/g;
X      system("$PAGER $safename");
X      unlink $TMPFILE;
X   }
}
$helpuser = "\t\tPrint this message";
$funcs{'h'} = *helpuser;
$funcs{'?'} = *helpuser;
X.fi
X.RE
X.PP
Note the use of various customization variables as well as the assignment
of the type glob to two different indices of the \fI%funcs\fR array.  Note
also that again we protect any meta characters from the shell.
X
Note that it is considered good form to \fIreturn()\fR from user defined
subroutines rather than terminating \fBPLOD\fR prematurely.  If you must
abort execution from within a routine, it is recommended that you
call \fI&PLODNormExit()\fR or \fI&PLODBadExit()\fR so that you get
both the \fBBACKUP\fR mechanism and the appropriate \fI&on_exit()\fR
or \fI&on_error()\fR call.
X
X.SH FILES
X.PP
X.Ip $HOME/.plodrc 24
Default location for users' personal initialization files
X.Sp
X.Ip /etc/plodrc 24
System-wide initialization file
X.Sp
X.PP
Various other customizable file locations.
X
X.SH SEE ALSO
X.BR perl (1)
X
X.SH AUTHORS
The original idea for \fBPLOD\fR comes from Bill Mendyka
(\fBmendyka@dg-rtp.dg.com\fR).
X
The current Perl implementation was developed by Hal Pomeranz
(\fBhal@deer-run.com\fR).
X
An Emacs mode for \fBPLOD\fR was developed by Paul Foley
(\fBpaul@ascent.com\fR), and another by Paul Hudson
(\fBpaulh@harlequin.com\fR).
X
Additional improvements have been suggested/developed by:
Bobby Billingsley (\fBbobby@dc.dk\fR),
David W Crabb (\fBcrabb@phoenix.Princeton.EDU\fR),
Michel Dignard (\fBdignard@ERE.UMontreal.CA\fR),
John Ellis (\fBellis@rtsg.mot.com\fR),
Bob Gibson (\fBrjg@sco.COM\fR),
Mike Lachowski (\fBmlachow@erenj.com\fR),
Eric Prestemon (\fBecprest@pocorvares.er.usgs.GOV\fR),
Erik E. Rantapaa (\fBrantapaa@math.umn.edu\fR),
Scot Schneebeli (\fBsls@tct.com\fR),
James Tizard (\fBjames@ringo.ssn.flinders.edu.au\fR),
and G. Paul Ziemba (\fBpaul@alantec.com\fR).
X
X.SH BUGS
Any bug reports or suggestions for improvement should be submitted to
Hal Pomeranz via email at \fBhal@deer-run.com\fR.
SHAR_EOF
  $shar_touch -am 01250806100 'plod.man' &&
  chmod 0644 'plod.man' ||
  $echo 'restore of' 'plod.man' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'plod.man:' 'MD5 check failed'
90a07be198b7361085b84c57f6ee4092  plod.man
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'plod.man'`"
    test 15156 -eq "$shar_count" ||
    $echo 'plod.man:' 'original size' '15156,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh02155
exit 0
